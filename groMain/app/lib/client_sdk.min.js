var ZSDKUtil = (function (ZSDKUtil) {
    var GlobalLogger,
      QueryParams = GetQueryParams()
    function ZLogger() {}
    function GetQueryParams(URL) {
      var qParams = {},
        currentURL = URL || window.location.href
      return (
        currentURL
          .substr(currentURL.indexOf('?') + 1)
          .split('&')
          .forEach(function (ele) {
            var miniSplit = ele.split('=')
            qParams[miniSplit[0]] = miniSplit[1]
          }),
        qParams.hasOwnProperty('serviceOrigin') && (qParams.serviceOrigin = decodeURIComponent(qParams.serviceOrigin)),
        qParams
      )
    }
    return (
      (ZLogger.prototype.Info = function () {
        ;(ZSDKUtil.isDevMode() || ZSDKUtil.isLogEnabled()) && console.info.apply(console, arguments)
      }),
      (ZLogger.prototype.Error = console.error),
      (ZSDKUtil.GetQueryParams = GetQueryParams),
      (ZSDKUtil.isDevMode = function () {
        return QueryParams && QueryParams.isDevMode
      }),
      (ZSDKUtil.isLogEnabled = function () {
        return QueryParams && QueryParams.isLogEnabled
      }),
      (ZSDKUtil.getLogger = function () {
        return (GlobalLogger && GlobalLogger instanceof ZLogger) || (GlobalLogger = new ZLogger()), GlobalLogger
      }),
      ZSDKUtil
    )
  })(window.ZSDKUtil || {}),
  ZSDKMessageManager = (function (ZSDKMessageManager) {
    var rootInstance,
      AuthParentWindow,
      AuthParentOrigin,
      Logger = ZSDKUtil.getLogger(),
      promiseIDCtr = 100,
      PromiseQueue = {},
      qParams = ZSDKUtil.GetQueryParams()
    function MessageHandler(MessageEvent) {
      var data
      try {
        data = 'string' == typeof MessageEvent.data ? JSON.parse(MessageEvent.data) : MessageEvent.data
      } catch (e) {
        data = MessageEvent.data
      }
      var payload,
        promiseID,
        response,
        isResolved,
        MEvent,
        incomingSource,
        incomingOrigin,
        messageType = data.type
      try {
        if ('__REGISTER__' === messageType || ((incomingSource = (MEvent = MessageEvent).source), (incomingOrigin = MEvent.origin), (rootInstance.isRegistered() && AuthParentWindow === incomingSource && AuthParentOrigin === incomingOrigin) || new Error('Un-Authorized Message.')))
          switch (messageType) {
            case '__REGISTER__':
              !(function (MessageEvent, payload) {
                ;(AuthParentWindow = window.parent), (AuthParentOrigin = qParams.serviceOrigin)
                var origin = window.location.origin
                ;(rootInstance.dcType = origin.split('.').pop().toUpperCase()), 'COM' === rootInstance.dcType && (rootInstance.dcType = 'US')
                ;(rootInstance.key = payload.uniqueID), (rootInstance.parentWindow = AuthParentWindow), (rootInstance._isRegistered = !0), SendEvent({ type: '__REGISTER__', widgetOrigin: getCurrentURLPath(), uniqueID: rootInstance.key }, rootInstance)
                var initData = payload.data
                executeEventHandlers(rootInstance, 'Load', initData)
              })(0, data)
              break
            case '__EVENT_RESPONSE__':
              ;(promiseID = (payload = data).promiseID), (response = payload.data), (isResolved = payload.isSuccess), PromiseQueue.hasOwnProperty(promiseID) && (isResolved ? PromiseQueue[promiseID].resolve(response) : PromiseQueue[promiseID].reject(response), (PromiseQueue[promiseID] = void 0), delete PromiseQueue[promiseID])
              break
            default:
              !(function (MessageEvent, data) {
                var responseArr,
                  widgetID = data.widgetID,
                  eventName = data.eventName
                if (rootInstance.key === widgetID) responseArr = executeEventHandlers(rootInstance, eventName, data.data)
                else {
                  var childInstance = rootInstance._childWidgets[widgetID]
                  childInstance && (responseArr = executeEventHandlers(childInstance, eventName, data.data))
                }
                if (data.isPromise) {
                  var obj = {}
                  Promise.all(responseArr)
                    .then(function (res) {
                      ;(obj.response = res), (obj.widgetID = widgetID), (obj.sourceWidgetID = rootInstance.key), sendPromiseEvent(data, obj)
                    })
                    .catch(function (err) {
                      ;(obj.response = err), (obj.widgetID = widgetID), (obj.sourceWidgetID = rootInstance.key), sendPromiseEvent(data, obj)
                    })
                }
              })(0, data)
          }
      } catch (e) {
        Logger.Error('[SDK.MessageHandler] => ', e.stack)
      }
    }
    function sendPromiseEvent(data, responseObj) {
      SendEvent({ type: '__EVENT_RESPONSE__', widgetOrigin: getCurrentURLPath(), uniqueID: rootInstance.key, eventName: data.eventName, data: responseObj, promiseID: data.promiseID }, rootInstance)
    }
    function executeEventHandlers(widgetInstance, eventName, data) {
      var handlersArray = widgetInstance.eventHandlers[eventName],
        responseArr = []
      if (Array.isArray(handlersArray))
        for (var i = 0; i < handlersArray.length; i++) {
          var response, responseObj
          try {
            responseObj =
              (response = handlersArray[i].call(widgetInstance, data)) instanceof Promise
                ? response
                    .then(function (_res) {
                      return { isSuccess: !0, response: _res }
                    })
                    .catch(function (err) {
                      return { isSuccess: !1, response: err }
                    })
                : { isSuccess: !0, response: response }
          } catch (e) {
            responseObj = { isSuccess: !1, response: e }
          }
          responseArr.push(responseObj)
        }
      return responseArr
    }
    function SendEvent(eventObject, instance) {
      var PromiseID,
        promiseID,
        isPromiseEvent = eventObject.isPromise
      if ((isPromiseEvent && ((PromiseID = 'Promise' + promiseIDCtr++), (eventObject.promiseID = PromiseID)), instance && ((eventObject.uniqueID = (instance.parentWidget || instance).key), (eventObject.widgetID = instance.key)), (eventObject.time = new Date().getTime()), PostMessage(eventObject), isPromiseEvent))
        return (
          (promiseID = PromiseID),
          new Promise(function (resolve, reject) {
            PromiseQueue[promiseID] = { resolve: resolve, reject: reject, time: new Date().getTime() }
          })
        )
    }
    function DERegisterApp() {
      PostMessage({ type: '__DEREGISTER__', uniqueID: rootInstance.key })
    }
    function PostMessage(data) {
      if (('object' == typeof data && (data.widgetOrigin = encodeURIComponent(getCurrentURLPath())), !AuthParentWindow)) throw new Error('Parentwindow reference not found.')
      AuthParentWindow.postMessage(data, qParams.serviceOrigin)
    }
    function getCurrentURLPath() {
      return window.location.protocol + '//' + window.location.host + window.location.pathname
    }
    return (
      (ZSDKMessageManager.Init = function (widgetInstance) {
        ;(rootInstance = widgetInstance), window.addEventListener('message', MessageHandler), window.addEventListener('unload', DERegisterApp)
      }),
      (ZSDKMessageManager.SendEvent = SendEvent),
      ZSDKMessageManager
    )
  })(window.ZSDKMessageManager || {})
;(window.ZSDK = (function () {
  var rootInstance,
    qParams = ZSDKUtil.GetQueryParams()
  function Widget(opts) {
    ;(this.serviceOrigin = opts.serviceOrigin || qParams.serviceOrigin), (this.parentWidget = opts.parentWidget), (this.key = opts.key), (this._isRegistered = !1), (this._childWidgets = {}), (this.eventHandlers = Object.create(null)), this.meta
  }
  return (
    (Widget.prototype.on = function (eventName, fn) {
      if ('string' != typeof eventName) throw new Error('Invalid eventname parameter passed.')
      if ('function' != typeof fn) throw new Error('Invalid function parameter passed.')
      var handlersArray = this.eventHandlers[eventName]
      if ((Array.isArray(handlersArray) || (this.eventHandlers[eventName] = handlersArray = []), handlersArray.push(fn), 'Load' !== eventName)) {
        var eventBindObj = { type: '__EVENT_BIND__', eventName: eventName, count: handlersArray.length }
        ;(this.parentWidget && !this.parentWidget.isRegistered()) || (!this.parentWidget && !this.isRegistered())
          ? (this.parentWidget || this).on('Load', function () {
              ZSDKMessageManager.SendEvent(eventBindObj, this)
            })
          : ZSDKMessageManager.SendEvent(eventBindObj, this)
      }
    }),
    (Widget.prototype.off = function (eventName, fn) {
      if ('string' != typeof eventName) throw new Error('Invalid eventname parameter passed.')
      if ('function' != typeof fn) throw new Error('Invalid function parameter passed.')
      var handlersArray = this.eventHandlers[eventName]
      if (Array.isArray(handlersArray)) {
        var i,
          indices = []
        for (i = 0; i < handlersArray.length; i++) handlersArray[i] === fn && indices.push(i)
        for (; indices.length; ) handlersArray.splice(indices.pop(), 1)
      }
    }),
    (Widget.prototype._sendEvent = function (eventName, data, isPromise) {
      var messageObj = { type: '__EVENT__', eventName: eventName, data: data, isPromise: isPromise }
      return ZSDKMessageManager.SendEvent(messageObj, this)
    }),
    (Widget.prototype.emit = function (eventName, data) {
      var messageObj = { type: '__EMIT__', eventName: eventName, data: data }
      ZSDKMessageManager.SendEvent(messageObj, this)
    }),
    (Widget.prototype.isRegistered = function () {
      return this._isRegistered
    }),
    (Widget.prototype.fetch = function (opts) {
      var messageObj = { eventName: '__HTTP__', isPromise: !0, options: opts }
      return ZSDKMessageManager.SendEvent(messageObj, this)
    }),
    (Widget.prototype.createInstance = function (opts) {
      var messageObj = { eventName: '__CREATE_INSTANCE__', isPromise: !0, options: opts }
      return ZSDKMessageManager.SendEvent(messageObj, this)
    }),
    (Widget.prototype.modal = function (opts) {
      return 'object' == typeof opts && (opts.location = '__MODAL__'), this.createInstance(opts)
    }),
    (Widget.prototype.getWidgets = function () {
      return ZSDKMessageManager.SendEvent({ eventName: '__WIDGETS_INFO__', isPromise: !0 }, this)
    }),
    (Widget.prototype.getWidgetInstance = function (widgetID) {
      if ('string' != typeof widgetID) throw new Error('Invalid WidgetID passed')
      if (this.parentWidget) return this.parentWidget.getWidgetInstance(widgetID)
      var widgetInstance = this._childWidgets[widgetID]
      return widgetInstance || (this._childWidgets[widgetID] = widgetInstance = new Widget({ key: widgetID, parentWidget: this })), widgetInstance
    }),
    (Widget.prototype.getFileObject = function (file) {
      return new File([file.slice(0, file.size)], file.name, { type: file.type })
    }),
    {
      Init: function () {
        return rootInstance || ((rootInstance = new Widget({ serviceOrigin: qParams.serviceOrigin })), ZSDKMessageManager.Init(rootInstance), rootInstance)
      },
      _getRootInstance: function () {
        return rootInstance
      },
    }
  )
})()),
  (window.SigmaSDK = (function () {
    var _zsdk,
      EVENT_TYPES_LOAD = 'Load',
      EVENT_TYPES_GET = 'get',
      EVENT_TYPES_GET_ALL = 'get_all',
      EVENT_TYPES_REMOVE = 'remove',
      EVENT_TYPES_REQUEST = 'request',
      EVENT_TYPES_EVENT_NAME_PREFIX = 'SIGMA_',
      EVENT_TYPES_EVENT_NAME_SUFFIX = '_EVENT',
      EVENT_TYPES_REQUEST_API_CONNECTION = 'requestapiconnection',
      ERROR_TYPES_VALIDATION = 'VALIDATION_ERROR',
      preValidation = function () {
        if (!_zsdk.isRegistered()) throw new Error('App not registered.')
      },
      sentEvent = function (_serviceName, eventData) {
        var eventName = EVENT_TYPES_EVENT_NAME_PREFIX + _serviceName + EVENT_TYPES_EVENT_NAME_SUFFIX
        return _zsdk._sendEvent(eventName, eventData, !0)
      },
      getErrorObject = function (type, message) {
        return Promise.reject({ type: type, message: message })
      }
    function UnifiedSDK(serviceName) {
      this._serviceName = serviceName
    }
    ;(UnifiedSDK.prototype.isRegistered = function () {
      return _zsdk.isRegistered()
    }),
      (UnifiedSDK.prototype.context = function () {
        return preValidation(), _zsdk
      }),
      (UnifiedSDK.prototype.createWidget = function (options) {
        return preValidation(), _zsdk.createInstance(options)
      }),
      (UnifiedSDK.prototype.getWidget = function (widgetId) {
        return _zsdk.getWidgetInstance(widgetId)
      }),
      (UnifiedSDK.prototype.widgetsMeta = function () {
        return preValidation(), _zsdk.getWidgets()
      }),
      (UnifiedSDK.prototype.on = function (eventName, handler) {
        return _zsdk.on(eventName, handler)
      }),
      (UnifiedSDK.prototype.off = function (eventName, handler) {
        return _zsdk.off(eventName, handler)
      }),
      (UnifiedSDK.prototype.trigger = function (eventName, options) {
        return preValidation(), _zsdk.emit(eventName, options)
      }),
      (UnifiedSDK.prototype.modal = function (options) {
        return preValidation(), _zsdk.modal(options)
      }),
      (UnifiedSDK.prototype.fetch = function (options) {
        return preValidation(), _zsdk.fetch(options)
      }),
      (UnifiedSDK.prototype.get = function (properties) {
        if ((preValidation(), 'string' != typeof properties && !Array.isArray(properties))) return getErrorObject(ERROR_TYPES_VALIDATION, 'The get method accepts String or Array of Strings only.')
        var propArr = 'string' == typeof properties ? [properties] : properties
        if (propArr.length <= 0) return getErrorObject(ERROR_TYPES_VALIDATION, 'The get method should not accept empty Array of Strings.')
        var eventData = { event_type: EVENT_TYPES_GET, properties: propArr }
        return sentEvent(this._serviceName, eventData)
      }),
      (UnifiedSDK.prototype.getAll = function (moduleName, options) {
        if ((preValidation(), 'string' != typeof moduleName)) return getErrorObject(ERROR_TYPES_VALIDATION, 'The getAll method accepts module_name as String only.')
        var eventData = { event_type: EVENT_TYPES_GET_ALL, module_name: moduleName, options: options }
        return sentEvent(this._serviceName, eventData)
      }),
      (UnifiedSDK.prototype.set = function (properties, propertyValue) {
        if ((preValidation(), 'string' != typeof properties && 'object' != typeof properties && Array.isArray(properties))) return getErrorObject(ERROR_TYPES_VALIDATION, 'The set method accepts key-value pair or Object of key-value pairs only.')
        var propArr
        if (('string' == typeof properties ? ((propArr = {})[properties] = propertyValue) : (propArr = properties), propArr.keys.length <= 0)) return getErrorObject(ERROR_TYPES_VALIDATION, 'The set method should not accept empty Object.')
        var eventData = { event_type: EVENT_TYPES_GET_ALL, properties: propArr }
        return sentEvent(this._serviceName, eventData)
      }),
      (UnifiedSDK.prototype.remove = function (properties) {
        if ((preValidation(), 'string' != typeof properties && !Array.isArray(properties))) return getErrorObject(ERROR_TYPES_VALIDATION, 'The remove method accepts String or Array of Strings only.')
        var propArr = 'string' == typeof properties ? [properties] : properties
        if (propArr.length <= 0) return getErrorObject(ERROR_TYPES_VALIDATION, 'The remove method should not accept empty Array of Strings.')
        var eventData = { event_type: EVENT_TYPES_REMOVE, properties: propArr }
        return sentEvent(this._serviceName, eventData)
      }),
      (UnifiedSDK.prototype.request = function (options) {
        if ((preValidation(), !options.url || options.url.trim().length <= 0)) return getErrorObject(ERROR_TYPES_VALIDATION, 'The parameter url should not be empty')
        if ('string' != typeof options.url) return getErrorObject(ERROR_TYPES_VALIDATION, 'The parameter url should be type of string')
        if ((options.method || (options.method = 'GET'), options.params && 'object' != typeof options.params && Array.isArray(options.params))) return getErrorObject(ERROR_TYPES_VALIDATION, 'The parameter params should be type of object')
        if (options.headers && 'object' != typeof options.headers && Array.isArray(options.headers)) return getErrorObject(ERROR_TYPES_VALIDATION, 'The parameter headers should be type of object')
        if (options.files) {
          if ('object' != typeof options.files || Array.isArray(options.files)) return getErrorObject(ERROR_TYPES_VALIDATION, 'The parameter files should be type of object')
          if (Object.keys(options.files).length > 5) return getErrorObject(ERROR_TYPES_VALIDATION, 'You can upload a maximum of 5 files at a time.')
          for (var i = 0; i < options.files.length; i++) options.files[i] = _zsdk.getFileObject(options.files[i])
        }
        var eventData = { event_type: EVENT_TYPES_REQUEST, options: options }
        return sentEvent(this._serviceName, eventData)
      }),
      (UnifiedSDK.prototype.requestapiconnection = function (options) {
        if ((preValidation(), !options.api_namespace || options.api_namespace.trim().length <= 0)) return getErrorObject(ERROR_TYPES_VALIDATION, 'The parameter api_namespace should not be empty')
        if ('string' != typeof options.api_namespace) return getErrorObject(ERROR_TYPES_VALIDATION, 'The parameter api_namespace should be type of string')
        if (!options.url || options.url.trim().length <= 0) return getErrorObject(ERROR_TYPES_VALIDATION, 'The parameter url should not be empty')
        if ('string' != typeof options.url) return getErrorObject(ERROR_TYPES_VALIDATION, 'The parameter url should be type of string')
        if ((options.method || (options.method = 'GET'), options.params && 'object' != typeof options.params && Array.isArray(options.params))) return getErrorObject(ERROR_TYPES_VALIDATION, 'The parameter params should be type of object')
        if (options.headers && 'object' != typeof options.headers && Array.isArray(options.headers)) return getErrorObject(ERROR_TYPES_VALIDATION, 'The parameter headers should be type of object')
        if (options.files) {
          if ('object' != typeof options.files || Array.isArray(options.files)) return getErrorObject(ERROR_TYPES_VALIDATION, 'The parameter files should be type of object')
          if (Object.keys(options.files).length > 5) return getErrorObject(ERROR_TYPES_VALIDATION, 'You can upload a maximum of 5 files at a time.')
          for (var i = 0; i < options.files.length; i++) options.files[i] = _zsdk.getFileObject(options.files[i])
        }
        var eventData = { event_type: EVENT_TYPES_REQUEST_API_CONNECTION, options: options }
        return sentEvent(this._serviceName, eventData)
      }),
      (UnifiedSDK.prototype.dispatch = function (eventType, options) {
        preValidation()
        var eventData = { event_type: eventType, options: options }
        return sentEvent(this._serviceName, eventData)
      })
    var init = function (handler) {
        return (_zsdk = window.ZSDK.Init()), 'function' == typeof handler && (_zsdk.isRegistered() ? handler.call() : _zsdk.on(EVENT_TYPES_LOAD, handler)), new UnifiedSDK(this._serviceName)
      },
      BIND_OBJECT_DESK = { _serviceName: 'DESK' },
      BIND_OBJECT_PROJECTS = { _serviceName: 'PROJECTS' },
      BIND_OBJECT_ORCHESTLY = { _serviceName: 'ORCHESTLY' },
      BIND_OBJECT_MAIL = { _serviceName: 'MAIL' },
      BIND_OBJECT_SHOW = { _serviceName: 'SHOW' },
      BIND_OBJECT_SDP = { _serviceName: 'SDP' },
      BIND_OBJECT_IOT = { _serviceName: 'IOT' },
      BIND_OBJECT_CATALYST = { _serviceName: 'CATALYST' },
      BIND_OBJECT_FINANCE = { _serviceName: 'FINANCE' },
      BIND_OBJECT_CONNECT = { _serviceName: 'CONNECT' },
      BIND_OBJECT_TEAMINBOX = { _serviceName: 'TEAMINBOX' },
      BIND_OBJECT_SPRINTS = { _serviceName: 'SPRINTS' },
      BIND_OBJECT_BUGTRACKER = { _serviceName: 'BUGTRACKER' },
      BIND_OBJECT_CREATOR = { _serviceName: 'CREATOR' },
      BIND_OBJECT_PEOPLE = { _serviceName: 'PEOPLE' },
      BIND_OBJECT_COMMERCE = { _serviceName: 'COMMERCE' },
      BIND_OBJECT_SITES = { _serviceName: 'SITES' },
      BIND_OBJECT_RECRUIT = { _serviceName: 'RECRUIT' },
      BIND_OBJECT_WORKDRIVE = { _serviceName: 'WORKDRIVE' },
      BIND_OBJECT_WRITER = { _serviceName: 'WRITER' },
      BIND_OBJECT_INVOICE = { _serviceName: 'INVOICE' },
      BIND_OBJECT_INVENTORY = { _serviceName: 'INVENTORY' },
      BIND_OBJECT_SUBSCRIPTIONS = { _serviceName: 'SUBSCRIPTIONS' },
      BIND_OBJECT_CAMPAIGNS = { _serviceName: 'CAMPAIGNS' },
      BIND_OBJECT_CHARMHEALTHEHR = { _serviceName: 'CHARMHEALTHEHR' },
      BIND_OBJECT_BIGIN = { _serviceName: 'BIGIN' }
    return { CRM: { init: init.bind({ _serviceName: 'CRM' }) }, DESK: { init: init.bind(BIND_OBJECT_DESK) }, PROJECTS: { init: init.bind(BIND_OBJECT_PROJECTS) }, ORCHESTLY: { init: init.bind(BIND_OBJECT_ORCHESTLY) }, MAIL: { init: init.bind(BIND_OBJECT_MAIL) }, SHOW: { init: init.bind(BIND_OBJECT_SHOW) }, SDP: { init: init.bind(BIND_OBJECT_SDP) }, IOT: { init: init.bind(BIND_OBJECT_IOT) }, CATALYST: { init: init.bind(BIND_OBJECT_CATALYST) }, FINANCE: { init: init.bind(BIND_OBJECT_FINANCE) }, CONNECT: { init: init.bind(BIND_OBJECT_CONNECT) }, TEAMINBOX: { init: init.bind(BIND_OBJECT_TEAMINBOX) }, SPRINTS: { init: init.bind(BIND_OBJECT_SPRINTS) }, BUGTRACKER: { init: init.bind(BIND_OBJECT_BUGTRACKER) }, CREATOR: { init: init.bind(BIND_OBJECT_CREATOR) }, PEOPLE: { init: init.bind(BIND_OBJECT_PEOPLE) }, COMMERCE: { init: init.bind(BIND_OBJECT_COMMERCE) }, SITES: { init: init.bind(BIND_OBJECT_SITES) }, RECRUIT: { init: init.bind(BIND_OBJECT_RECRUIT) }, WORKDRIVE: { init: init.bind(BIND_OBJECT_WORKDRIVE) }, WRITER: { init: init.bind(BIND_OBJECT_WRITER) }, INVOICE: { init: init.bind(BIND_OBJECT_INVOICE) }, INVENTORY: { init: init.bind(BIND_OBJECT_INVENTORY) }, SUBSCRIPTIONS: { init: init.bind(BIND_OBJECT_SUBSCRIPTIONS) }, CAMPAIGNS: { init: init.bind(BIND_OBJECT_CAMPAIGNS) }, CHARMHEALTHEHR: { init: init.bind(BIND_OBJECT_CHARMHEALTHEHR) }, BIGIN: { init: init.bind(BIND_OBJECT_BIGIN) } }
  })())
var zohoprojects = {},
  zohobugtracker = {},
  js_sdk = (function () {
    var sdk
    return {
      init: function () {
        return (
          (sdk = ZSDK.Init()),
          new Promise(function (resolve, reject) {
            sdk.on('Load', function () {
              resolve()
            })
          })
        )
      },
      context: function () {
        return sdk._sendEvent('context', {}, !0)
      },
      metadata: function () {
        return sdk._sendEvent('metadata', {}, !0)
      },
      get: function (key) {
        return 'instances' === key ? sdk.getWidgets() : sdk._sendEvent('get', key, !0)
      },
      set: function (module_name, value) {
        if ('string' != typeof module_name) return Promise.reject('module_name should be of type string.')
        if (module_name.length <= 0) return Promise.reject('Specify a valid module name.')
        var property = {}
        return (property[module_name] = value), sdk._sendEvent('set', property, !0)
      },
      instance: function (widget_id) {
        return sdk.getWidgetInstance(widget_id)
      },
      emit: function (name, data) {
        return sdk.emit(name, data)
      },
      on: function (name, handler) {
        return sdk.on(name, handler)
      },
      invoke: function (action, options) {
        if ('modal.create' !== action || 'object' != typeof options || Array.isArray(options)) {
          var perform = {}
          return (perform.action = action), (perform.options = options), sdk._sendEvent('invoke', perform, !0)
        }
        if (options.url) return sdk.modal(options)
      },
      request: function (url, options, connection) {
        if ('string' != typeof url) return Promise.reject('URL should be of type string.')
        if (url.length <= 0) return Promise.reject('Specify a valid URL.')
        if (void 0 !== options && ('object' != typeof options || Array.isArray(options))) return Promise.reject('options should be of type object.')
        if ((void 0 === options && (options = {}), (options.url = url), void 0 !== connection && 'string' != typeof connection)) return Promise.reject('connection should be of type string.')
        if (((options.connection = connection), void 0 === options.type && (options.type = 'GET'), void 0 === options.replace_secure_config && (options.replace_secure_config = !1), void 0 !== options.files)) {
          if ('object' != typeof options.files || !Array.isArray(options.files)) return Promise.reject('Data type mismatch for files')
          if (0 === options.files.length || options.files.length > 6) return Promise.reject('You can upload a maximum of 5 files at a time.')
          for (var i = 0; i < options.files.length; i++) for (var file in options.files[i]) 'type' !== file && (options.files[i][file] = sdk.getFileObject(options.files[i][file]))
        }
        return sdk._sendEvent('request', options, !0)
      },
      app: {
        store: function (key, value) {
          return zohoprojects.store(key, value, 'app')
        },
        retrieve: function (property_key) {
          return zohoprojects.retrieve(property_key, 'app')
        },
        update: function (property) {
          return zohoprojects.update(property, 'app')
        },
        remove: function (property_id) {
          return zohoprojects.remove(property_id, 'app')
        },
      },
      entity: {
        store: function (key, value) {
          return zohoprojects.store(key, value, 'entity')
        },
        retrieve: function (property_key) {
          return zohoprojects.retrieve(property_key, 'entity')
        },
        update: function (property) {
          return zohoprojects.update(property, 'entity')
        },
        remove: function (property_id) {
          return zohoprojects.remove(property_id, 'entity')
        },
      },
      store: function (key, value, entity_type) {
        if ('string' != typeof key) return Promise.reject('key should be of type string.')
        if (key.length <= 0) return Promise.reject('Specify a valid key.')
        if ('object' != typeof value) return Promise.reject('value should be of type object.')
        var property = {}
        property[key] = value
        var options = {}
        return (options.property = property), (options.entity_type = entity_type), sdk._sendEvent('store', options, !0)
      },
      retrieve: function (property_key, entity_type) {
        if ('string' != typeof property_key) return Promise.reject('key should be of type string.')
        if (property_key.length <= 0) return Promise.reject('Specify a valid key.')
        var options = {}
        return (options.property_key = property_key), (options.entity_type = entity_type), sdk._sendEvent('retrieve', options, !0)
      },
      update: function (property, entity_type) {
        if ('object' != typeof property) return Promise.reject('property should be of type object.')
        if ('string' != typeof property.id) return Promise.reject('property id should be of type string.')
        if (property.id.length <= 0) return Promise.reject('Specify a valid property id.')
        if ('string' != typeof property.key) return Promise.reject('property key should be of type string.')
        if (property.key.length <= 0) return Promise.reject('Specify a valid key.')
        if ('object' != typeof property.value) return Promise.reject('property value should be of type object.')
        var prop = {},
          prop_pair = {}
        ;(prop_pair[property.key] = property.value), (prop[property.id] = prop_pair)
        var options = {}
        return (options.property = prop), (options.entity_type = entity_type), sdk._sendEvent('update', options, !0)
      },
      remove: function (property_id, entity_type) {
        var options = {}
        return (options.entity_type = entity_type), (options.property = property_id), sdk._sendEvent('remove', options, !0)
      },
    }
  })()
;(zohoprojects = js_sdk), (zohobugtracker = js_sdk)
